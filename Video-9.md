# Video 9: History of Programming Languages

## Timeline

| Year | Language | Purpose | Why It Emerged (Previous Limitations) |
|------|----------|---------|--------------------------------------|
| 1940s | **Machine Language** | Binary (0s & 1s) - direct CPU instructions | First computers needed direct hardware control |
| 1950s | **Assembly** | Mnemonics like `MOV AL, 61h` | Machine code was too hard to read/write |
| 1957 | **FORTRAN** | Scientific computing (John Backus, IBM) | Assembly was tedious; needed math-friendly syntax |
| 1959 | **COBOL** | Business apps (Grace Hopper) - still used in banks! | FORTRAN wasn't suited for business/data processing |
| 1970 | **Pascal** | Structured programming (Niklaus Wirth) | Needed better code organization & teaching language |
| 1972 | **C** | Systems/UNIX (Dennis Ritchie) | Needed low-level power with high-level readability |
| 1983 | **C++** | C + OOP (Bjarne Stroustrup) | C lacked OOP for complex software (no encapsulation, inheritance) |
| 1991 | **Visual Basic** | RAD for Windows apps (Microsoft) | C/C++ too complex for rapid GUI development |
| 1995 | **Java** | Platform-independent (James Gosling) | C++ wasn't portable; needed "write once, run anywhere" |
| 2000 | **C#** | Modern .NET (Anders Hejlsberg, Microsoft) | Java lacked Windows integration; C++ too complex |

## Key Points
- **Low-level** → Machine/Assembly (hardware-specific)
- **High-level** → FORTRAN onwards (human-readable)
- **C# combines** best of C++, Java + modern features

Procedural Programming vs Object-Oriented Programming (OOP):

- **Procedural**: Step-by-step instructions (e.g., C, FORTRAN)
- **OOP**: Objects with data + behavior (e.g., C++, Java, C#)

Procedural languages were missing Security and Reusability features, which led to the rise of OOP languages. 


